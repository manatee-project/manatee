// Copyright 2024 TikTok Pte. Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Code generated by hertz generator.

package job

import (
	"context"
	"mime/multipart"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	"github.com/manatee-project/manatee/app/dcr_api/biz/model/job"
	"github.com/manatee-project/manatee/app/dcr_api/biz/pkg/errno"
	"github.com/manatee-project/manatee/app/dcr_api/biz/pkg/utils"
	"github.com/manatee-project/manatee/app/dcr_api/biz/service"
)

type FileParas struct {
	FileHeader      *multipart.FileHeader `form:"file"`
	Creator         string                `form:"creator"`
	Envs            []*job.Env            `form:"envs"`
	JupyterFileName string                `form:"filename"`
	CPUCount        int64                 `form:"cpu_count"`
	DiskSize        int64                 `form:"disk_size"`
	AccessToken     string                `header:"Authorization,required"`
}

// CreateJob .
// @router /v1/job/submit/ [POST]
func SubmitJob(ctx context.Context, c *app.RequestContext) {
	var req job.SubmitJobRequest
	var formReq FileParas
	err := c.BindAndValidate(&formReq)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}

	cpuCounts := []int64{2, 4, 8, 16, 32, 48, 64, 80, 96, 128, 224}
	rounded := cpuCounts[len(cpuCounts)-1]

	for _, count := range cpuCounts {
		if formReq.CPUCount <= count {
			rounded = count
			break
		}
	}

	formReq.CPUCount = rounded

	req.JupyterFileName = formReq.JupyterFileName
	req.AccessToken = formReq.AccessToken
	req.Creator = formReq.Creator
	req.Envs = formReq.Envs
	req.CPUCount = formReq.CPUCount
	req.DiskSize = formReq.DiskSize
	file, err := formReq.FileHeader.Open()
	if err != nil {
		hlog.Errorf("[Job Handler]failed to open file %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	defer file.Close()

	UUID, err := service.NewJobService(ctx).SubmitJob(&req, file)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to submit file %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	c.JSON(consts.StatusOK, job.SubmitJobResponse{
		Code: errno.SuccessCode,
		Msg:  errno.SuccessMsg,
		UUID: UUID,
	})
}

// QueryJob .
// @router /v1/job/query/ [POST]
func QueryJob(ctx context.Context, c *app.RequestContext) {
	var err error
	var req job.QueryJobRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	jobs, total, err := service.NewJobService(ctx).QueryUsersJobs(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to query user jobs %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	c.JSON(consts.StatusOK, job.QueryJobResponse{
		Code:  errno.SuccessCode,
		Msg:   errno.SuccessMsg,
		Jobs:  jobs,
		Total: total,
	})
}

// DeleteJob .
// @router /v1/job/delete/ [POST]
func DeleteJob(ctx context.Context, c *app.RequestContext) {
	var err error
	var req job.DeleteJobRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	service.NewJobService(ctx).DeleteJob(&req)
	c.JSON(consts.StatusOK, job.DeleteJobResponse{
		Code: errno.SuccessCode,
		Msg:  errno.SuccessMsg,
	})
}

// QueryJobOutputAttr .
// @router /v1/job/file/attrs/ [POST]
func QueryJobOutputAttr(ctx context.Context, c *app.RequestContext) {
	var err error
	var req job.QueryJobOutputRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	file, size, err := service.NewJobService(ctx).GetJobOutputAttrs(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to get job output attributes: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	c.JSON(consts.StatusOK, job.QueryJobOutputResponse{
		Code:     errno.SuccessCode,
		Msg:      errno.SuccessMsg,
		Filename: file,
		Size:     size,
	})
}

// DownloadJobOutput .
// @router /v1/job/file/download/ [POST]
func DownloadJobOutput(ctx context.Context, c *app.RequestContext) {
	var err error
	var req job.DownloadJobOutputRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	content, err := service.NewJobService(ctx).DownloadJobOutput(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to download job output: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}

	c.JSON(consts.StatusOK, job.DownloadJobOutputResponse{
		Code:    errno.SuccessCode,
		Msg:     errno.SuccessMsg,
		Content: content,
	})
}

// QueryJobAttestationReport .
// @router /v1/job/attestation/ [POST]
func QueryJobAttestationReport(ctx context.Context, c *app.RequestContext) {
	var err error
	var req job.QueryJobAttestationRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to parse parameters: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	report, err := service.NewJobService(ctx).GetJobAttestationReport(&req)
	if err != nil {
		hlog.Errorf("[Job Handler]failed to query job attestation report: %+v", err)
		utils.ReturnsJSONError(c, err)
		return
	}
	c.JSON(consts.StatusOK, job.QueryJobAttestationResponse{
		Code:  errno.SuccessCode,
		Msg:   errno.SuccessMsg,
		Token: report,
	})
}
